{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///C:/laragon/www/claude/ecommerce-platform/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log: ['query'],\n  });\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,KAAK;QAAC;KAAQ;AAChB;AAEF,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 129, "column": 0}, "map": {"version":3,"sources":["file:///C:/laragon/www/claude/ecommerce-platform/src/lib/auth.ts"],"sourcesContent":["import { NextAuthOptions } from 'next-auth';\nimport CredentialsProvider from 'next-auth/providers/credentials';\nimport { PrismaAdapter } from '@next-auth/prisma-adapter';\nimport { prisma } from './prisma';\nimport { compare } from 'bcryptjs';\n\nexport const authOptions: NextAuthOptions = {\n  adapter: PrismaAdapter(prisma),\n  session: {\n    strategy: 'jwt',\n  },\n  pages: {\n    signIn: '/admin/login',\n  },\n  providers: [\n    CredentialsProvider({\n      name: 'credentials',\n      credentials: {\n        email: { label: 'Email', type: 'email' },\n        password: { label: 'Password', type: 'password' },\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) {\n          return null;\n        }\n\n        const user = await prisma.user.findUnique({\n          where: {\n            email: credentials.email,\n          },\n        });\n\n        if (!user || !user.password) {\n          return null;\n        }\n\n        const isPasswordValid = await compare(\n          credentials.password,\n          user.password\n        );\n\n        if (!isPasswordValid) {\n          return null;\n        }\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          role: user.role,\n        };\n      },\n    }),\n  ],\n  callbacks: {\n    async jwt({ token, user, trigger }) {\n      if (user) {\n        return {\n          ...token,\n          id: user.id,\n          role: user.role,\n        };\n      }\n\n      // Validate session hasn't been invalidated\n      if (token.id) {\n        const dbUser = await prisma.user.findUnique({\n          where: { id: token.id as string },\n          select: { sessionsInvalidatedAt: true, role: true },\n        });\n\n        if (dbUser) {\n          // Check if JWT was issued before sessions were invalidated\n          if (dbUser.sessionsInvalidatedAt) {\n            const tokenIssuedAt = token.iat ? token.iat * 1000 : 0; // Convert to milliseconds\n            const invalidatedAt = new Date(dbUser.sessionsInvalidatedAt).getTime();\n\n            if (tokenIssuedAt < invalidatedAt) {\n              // Session has been invalidated - return null to force re-login\n              return null as any;\n            }\n          }\n\n          // Update role in token if it changed\n          token.role = dbUser.role;\n        } else {\n          // User no longer exists\n          return null as any;\n        }\n      }\n\n      return token;\n    },\n    async session({ session, token }) {\n      // If token is null, session is invalid\n      if (!token) {\n        return null as any;\n      }\n\n      return {\n        ...session,\n        user: {\n          ...session.user,\n          id: token.id,\n          role: token.role,\n        },\n      };\n    },\n  },\n};\n"],"names":[],"mappings":";;;;AACA;AACA;AACA;AACA;;;;;AAEO,MAAM,cAA+B;IAC1C,SAAS,IAAA,uLAAa,EAAC,gIAAM;IAC7B,SAAS;QACP,UAAU;IACZ;IACA,OAAO;QACL,QAAQ;IACV;IACA,WAAW;QACT,IAAA,qKAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU;oBACjD,OAAO;gBACT;gBAEA,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;oBACxC,OAAO;wBACL,OAAO,YAAY,KAAK;oBAC1B;gBACF;gBAEA,IAAI,CAAC,QAAQ,CAAC,KAAK,QAAQ,EAAE;oBAC3B,OAAO;gBACT;gBAEA,MAAM,kBAAkB,MAAM,IAAA,8IAAO,EACnC,YAAY,QAAQ,EACpB,KAAK,QAAQ;gBAGf,IAAI,CAAC,iBAAiB;oBACpB,OAAO;gBACT;gBAEA,OAAO;oBACL,IAAI,KAAK,EAAE;oBACX,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI;oBACf,MAAM,KAAK,IAAI;gBACjB;YACF;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE;YAChC,IAAI,MAAM;gBACR,OAAO;oBACL,GAAG,KAAK;oBACR,IAAI,KAAK,EAAE;oBACX,MAAM,KAAK,IAAI;gBACjB;YACF;YAEA,2CAA2C;YAC3C,IAAI,MAAM,EAAE,EAAE;gBACZ,MAAM,SAAS,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;oBAC1C,OAAO;wBAAE,IAAI,MAAM,EAAE;oBAAW;oBAChC,QAAQ;wBAAE,uBAAuB;wBAAM,MAAM;oBAAK;gBACpD;gBAEA,IAAI,QAAQ;oBACV,2DAA2D;oBAC3D,IAAI,OAAO,qBAAqB,EAAE;wBAChC,MAAM,gBAAgB,MAAM,GAAG,GAAG,MAAM,GAAG,GAAG,OAAO,GAAG,0BAA0B;wBAClF,MAAM,gBAAgB,IAAI,KAAK,OAAO,qBAAqB,EAAE,OAAO;wBAEpE,IAAI,gBAAgB,eAAe;4BACjC,+DAA+D;4BAC/D,OAAO;wBACT;oBACF;oBAEA,qCAAqC;oBACrC,MAAM,IAAI,GAAG,OAAO,IAAI;gBAC1B,OAAO;oBACL,wBAAwB;oBACxB,OAAO;gBACT;YACF;YAEA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,uCAAuC;YACvC,IAAI,CAAC,OAAO;gBACV,OAAO;YACT;YAEA,OAAO;gBACL,GAAG,OAAO;gBACV,MAAM;oBACJ,GAAG,QAAQ,IAAI;oBACf,IAAI,MAAM,EAAE;oBACZ,MAAM,MAAM,IAAI;gBAClB;YACF;QACF;IACF;AACF"}},
    {"offset": {"line": 246, "column": 0}, "map": {"version":3,"sources":["file:///C:/laragon/www/claude/ecommerce-platform/src/app/api/admin/cms/pages/%5Bid%5D/sync-blocks/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '@/lib/auth';\nimport { prisma } from '@/lib/prisma';\nimport { z } from 'zod';\n\nconst syncBlocksSchema = z.object({\n    blocks: z.array(z.object({\n        id: z.string().optional(), // Optional for new blocks\n        templateId: z.string(),\n        containerType: z.enum(['BLOCK', 'SECTION', 'FLEXBOX', 'GRID']).optional().default('BLOCK'),\n        parentId: z.string().nullable().optional(),\n        contentConfig: z.any(),\n        styleConfig: z.any().optional(),\n        advancedConfig: z.any().optional(),\n        layoutSettings: z.any().optional(),\n        order: z.number(),\n        isVisible: z.boolean().optional().default(true),\n        // Legacy config for backwards compatibility\n        config: z.any().optional(),\n    })),\n});\n\nexport async function POST(\n    request: NextRequest,\n    { params }: { params: Promise<{ id: string }> }\n) {\n    try {\n        const session = await getServerSession(authOptions);\n        if (!session?.user || !['ADMIN', 'SUPERADMIN', 'MANAGER'].includes(session.user.role)) {\n            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n        }\n\n        const { id } = await params;\n        const body = await request.json();\n        const { blocks } = syncBlocksSchema.parse(body);\n\n        // Verify page exists and user has access\n        const page = await prisma.page.findUnique({\n            where: { id },\n            include: { blocks: true },\n        });\n\n        if (!page) {\n            return NextResponse.json({ error: 'Page not found' }, { status: 404 });\n        }\n\n        // Get existing block IDs\n        const existingBlockIds = page.blocks.map(b => b.id);\n        const incomingBlockIds = blocks.filter(b => b.id && !b.id.startsWith('temp-')).map(b => b.id!);\n\n        // Validate all template IDs exist before proceeding\n        const uniqueTemplateIds = [...new Set(blocks.map(b => b.templateId).filter(Boolean))];\n        if (uniqueTemplateIds.length > 0) {\n            const existingTemplates = await prisma.blockTemplate.findMany({\n                where: {\n                    id: { in: uniqueTemplateIds },\n                },\n                select: { id: true },\n            });\n\n            const existingTemplateIds = new Set(existingTemplates.map(t => t.id));\n            const missingTemplateIds = uniqueTemplateIds.filter(id => !existingTemplateIds.has(id));\n\n            if (missingTemplateIds.length > 0) {\n                console.error('Missing template IDs:', missingTemplateIds);\n                return NextResponse.json(\n                    {\n                        error: 'Invalid template IDs',\n                        details: `The following template IDs do not exist: ${missingTemplateIds.join(', ')}`,\n                        missingTemplateIds,\n                    },\n                    { status: 400 }\n                );\n            }\n        }\n\n        // Delete blocks that are no longer in the list\n        const blocksToDelete = existingBlockIds.filter(id => !incomingBlockIds.includes(id));\n        if (blocksToDelete.length > 0) {\n            await prisma.contentBlock.deleteMany({\n                where: {\n                    id: { in: blocksToDelete },\n                    pageId: id,\n                },\n            });\n        }\n\n        // Upsert blocks (create new or update existing)\n        for (const block of blocks) {\n            const isNewBlock = !block.id || block.id.startsWith('temp-');\n\n            // Validate templateId\n            if (!block.templateId) {\n                console.error('Block missing templateId:', block);\n                continue; // Skip this block\n            }\n\n            // Prepare block data\n            const blockData = {\n                templateId: block.templateId,\n                containerType: block.containerType || 'BLOCK',\n                parentId: block.parentId || null,\n                contentConfig: block.contentConfig || block.config || {},\n                styleConfig: block.styleConfig || {},\n                advancedConfig: block.advancedConfig || {},\n                layoutSettings: block.layoutSettings || null,\n                order: block.order,\n                isVisible: block.isVisible !== false,\n                // Keep legacy config for backwards compatibility\n                config: block.config || block.contentConfig || {},\n            };\n\n            try {\n                if (isNewBlock) {\n                    // Create new block\n                    await prisma.contentBlock.create({\n                        data: {\n                            ...blockData,\n                            pageId: id,\n                        },\n                    });\n                } else {\n                    // Update existing block\n                    await prisma.contentBlock.update({\n                        where: { id: block.id },\n                        data: blockData,\n                    });\n                }\n            } catch (blockError) {\n                console.error('Error saving block:', {\n                    blockId: block.id,\n                    templateId: block.templateId,\n                    error: blockError,\n                });\n                // Continue with other blocks instead of failing completely\n            }\n        }\n\n        // Fetch updated page with blocks\n        const updatedPage = await prisma.page.findUnique({\n            where: { id },\n            include: {\n                blocks: {\n                    include: { \n                        template: true, // Include full template data including configSchema\n                    },\n                    orderBy: { order: 'asc' },\n                },\n            },\n        });\n\n        return NextResponse.json({\n            success: true,\n            page: updatedPage,\n        });\n    } catch (error) {\n        console.error('Error syncing blocks:', error);\n        if (error instanceof z.ZodError) {\n            return NextResponse.json(\n                { error: 'Invalid request data', details: error.issues },\n                { status: 400 }\n            );\n        }\n        return NextResponse.json(\n            { error: 'Failed to sync blocks' },\n            { status: 500 }\n        );\n    }\n}\n\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA,MAAM,mBAAmB,oLAAC,CAAC,MAAM,CAAC;IAC9B,QAAQ,oLAAC,CAAC,KAAK,CAAC,oLAAC,CAAC,MAAM,CAAC;QACrB,IAAI,oLAAC,CAAC,MAAM,GAAG,QAAQ;QACvB,YAAY,oLAAC,CAAC,MAAM;QACpB,eAAe,oLAAC,CAAC,IAAI,CAAC;YAAC;YAAS;YAAW;YAAW;SAAO,EAAE,QAAQ,GAAG,OAAO,CAAC;QAClF,UAAU,oLAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ;QACxC,eAAe,oLAAC,CAAC,GAAG;QACpB,aAAa,oLAAC,CAAC,GAAG,GAAG,QAAQ;QAC7B,gBAAgB,oLAAC,CAAC,GAAG,GAAG,QAAQ;QAChC,gBAAgB,oLAAC,CAAC,GAAG,GAAG,QAAQ;QAChC,OAAO,oLAAC,CAAC,MAAM;QACf,WAAW,oLAAC,CAAC,OAAO,GAAG,QAAQ,GAAG,OAAO,CAAC;QAC1C,4CAA4C;QAC5C,QAAQ,oLAAC,CAAC,GAAG,GAAG,QAAQ;IAC5B;AACJ;AAEO,eAAe,KAClB,OAAoB,EACpB,EAAE,MAAM,EAAuC;IAE/C,IAAI;QACA,MAAM,UAAU,MAAM,IAAA,2JAAgB,EAAC,mIAAW;QAClD,IAAI,CAAC,SAAS,QAAQ,CAAC;YAAC;YAAS;YAAc;SAAU,CAAC,QAAQ,CAAC,QAAQ,IAAI,CAAC,IAAI,GAAG;YACnF,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACtE;QAEA,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM;QACrB,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,MAAM,EAAE,GAAG,iBAAiB,KAAK,CAAC;QAE1C,yCAAyC;QACzC,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YACtC,OAAO;gBAAE;YAAG;YACZ,SAAS;gBAAE,QAAQ;YAAK;QAC5B;QAEA,IAAI,CAAC,MAAM;YACP,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAiB,GAAG;gBAAE,QAAQ;YAAI;QACxE;QAEA,yBAAyB;QACzB,MAAM,mBAAmB,KAAK,MAAM,CAAC,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE;QAClD,MAAM,mBAAmB,OAAO,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,CAAC,UAAU,CAAC,UAAU,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE;QAE5F,oDAAoD;QACpD,MAAM,oBAAoB;eAAI,IAAI,IAAI,OAAO,GAAG,CAAC,CAAA,IAAK,EAAE,UAAU,EAAE,MAAM,CAAC;SAAU;QACrF,IAAI,kBAAkB,MAAM,GAAG,GAAG;YAC9B,MAAM,oBAAoB,MAAM,gIAAM,CAAC,aAAa,CAAC,QAAQ,CAAC;gBAC1D,OAAO;oBACH,IAAI;wBAAE,IAAI;oBAAkB;gBAChC;gBACA,QAAQ;oBAAE,IAAI;gBAAK;YACvB;YAEA,MAAM,sBAAsB,IAAI,IAAI,kBAAkB,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE;YACnE,MAAM,qBAAqB,kBAAkB,MAAM,CAAC,CAAA,KAAM,CAAC,oBAAoB,GAAG,CAAC;YAEnF,IAAI,mBAAmB,MAAM,GAAG,GAAG;gBAC/B,QAAQ,KAAK,CAAC,yBAAyB;gBACvC,OAAO,gJAAY,CAAC,IAAI,CACpB;oBACI,OAAO;oBACP,SAAS,CAAC,yCAAyC,EAAE,mBAAmB,IAAI,CAAC,OAAO;oBACpF;gBACJ,GACA;oBAAE,QAAQ;gBAAI;YAEtB;QACJ;QAEA,+CAA+C;QAC/C,MAAM,iBAAiB,iBAAiB,MAAM,CAAC,CAAA,KAAM,CAAC,iBAAiB,QAAQ,CAAC;QAChF,IAAI,eAAe,MAAM,GAAG,GAAG;YAC3B,MAAM,gIAAM,CAAC,YAAY,CAAC,UAAU,CAAC;gBACjC,OAAO;oBACH,IAAI;wBAAE,IAAI;oBAAe;oBACzB,QAAQ;gBACZ;YACJ;QACJ;QAEA,gDAAgD;QAChD,KAAK,MAAM,SAAS,OAAQ;YACxB,MAAM,aAAa,CAAC,MAAM,EAAE,IAAI,MAAM,EAAE,CAAC,UAAU,CAAC;YAEpD,sBAAsB;YACtB,IAAI,CAAC,MAAM,UAAU,EAAE;gBACnB,QAAQ,KAAK,CAAC,6BAA6B;gBAC3C,UAAU,kBAAkB;YAChC;YAEA,qBAAqB;YACrB,MAAM,YAAY;gBACd,YAAY,MAAM,UAAU;gBAC5B,eAAe,MAAM,aAAa,IAAI;gBACtC,UAAU,MAAM,QAAQ,IAAI;gBAC5B,eAAe,MAAM,aAAa,IAAI,MAAM,MAAM,IAAI,CAAC;gBACvD,aAAa,MAAM,WAAW,IAAI,CAAC;gBACnC,gBAAgB,MAAM,cAAc,IAAI,CAAC;gBACzC,gBAAgB,MAAM,cAAc,IAAI;gBACxC,OAAO,MAAM,KAAK;gBAClB,WAAW,MAAM,SAAS,KAAK;gBAC/B,iDAAiD;gBACjD,QAAQ,MAAM,MAAM,IAAI,MAAM,aAAa,IAAI,CAAC;YACpD;YAEA,IAAI;gBACA,IAAI,YAAY;oBACZ,mBAAmB;oBACnB,MAAM,gIAAM,CAAC,YAAY,CAAC,MAAM,CAAC;wBAC7B,MAAM;4BACF,GAAG,SAAS;4BACZ,QAAQ;wBACZ;oBACJ;gBACJ,OAAO;oBACH,wBAAwB;oBACxB,MAAM,gIAAM,CAAC,YAAY,CAAC,MAAM,CAAC;wBAC7B,OAAO;4BAAE,IAAI,MAAM,EAAE;wBAAC;wBACtB,MAAM;oBACV;gBACJ;YACJ,EAAE,OAAO,YAAY;gBACjB,QAAQ,KAAK,CAAC,uBAAuB;oBACjC,SAAS,MAAM,EAAE;oBACjB,YAAY,MAAM,UAAU;oBAC5B,OAAO;gBACX;YACA,2DAA2D;YAC/D;QACJ;QAEA,iCAAiC;QACjC,MAAM,cAAc,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YAC7C,OAAO;gBAAE;YAAG;YACZ,SAAS;gBACL,QAAQ;oBACJ,SAAS;wBACL,UAAU;oBACd;oBACA,SAAS;wBAAE,OAAO;oBAAM;gBAC5B;YACJ;QACJ;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT,MAAM;QACV;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,yBAAyB;QACvC,IAAI,iBAAiB,oLAAC,CAAC,QAAQ,EAAE;YAC7B,OAAO,gJAAY,CAAC,IAAI,CACpB;gBAAE,OAAO;gBAAwB,SAAS,MAAM,MAAM;YAAC,GACvD;gBAAE,QAAQ;YAAI;QAEtB;QACA,OAAO,gJAAY,CAAC,IAAI,CACpB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAEtB;AACJ"}}]
}