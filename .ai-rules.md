# AI Assistant Rules for E-Commerce Platform

This file contains essential rules and guidelines for AI assistants working on this project. These rules help maintain consistency, quality, and best practices across the codebase.

---

## 1. Project Context

### Tech Stack
- **Framework**: Next.js 16+ (App Router)
- **Language**: TypeScript
- **Styling**: Tailwind CSS 4 + Shadcn/ui components
- **State Management**: Redux Toolkit + Redux Persist
- **Database**: MySQL with Prisma ORM
- **Authentication**: NextAuth.js
- **Testing**: Vitest + React Testing Library
- **Internationalization**: next-intl
- **File Storage**: Cloudinary (configurable)

### Architecture
- Server Components by default (React Server Components)
- API Routes in `src/app/api/`
- Server Actions in `src/lib/actions/`
- Client components only when needed (interactivity, hooks, browser APIs)

---

## 2. Code Style & Conventions

### TypeScript
- Prefer type safety even though project has `strict: false`
- Use proper types for all function parameters and return values
- Avoid `any` type - use `unknown` if type is truly unknown
- Use Prisma generated types from `@prisma/client`

### React & Next.js
- Use Server Components by default
- Mark client components with `"use client"` directive
- Prefer Server Actions over API routes when possible
- Use async/await for all async operations
- Implement proper error boundaries and loading states

### Component Patterns
- Use Shadcn/ui components from `@/components/ui`
- Follow existing component structure and naming conventions
- Extract reusable logic into custom hooks
- Keep components focused and single-purpose

### User Experience
- **Always add help text under inputs** - Users love help texts that explain what the input or action will do
- **Use alerts for sensitive actions** - Destructive or critical actions should show confirmation dialogs
- Provide clear error messages with actionable guidance
- Show loading states during async operations
- Use toast notifications for success/error feedback (react-hot-toast)

### State Management
- Use Redux Toolkit for global state (cart, user preferences)
- Use React state for local component state
- Use SWR for client-side data fetching when needed
- Follow existing Redux patterns in `src/store/`

---

## 3. Project Structure

### Directory Organization
```
src/
├── app/              # Next.js App Router pages and routes
│   ├── [locale]/     # Internationalized routes
│   ├── admin/        # Admin dashboard pages
│   └── api/          # API route handlers
├── components/       # React components
│   ├── ui/           # Shadcn/ui base components
│   ├── admin/        # Admin-specific components
│   ├── storefront/   # Customer-facing components
│   └── blocks/       # CMS content blocks
├── lib/              # Utilities and server-side code
│   ├── actions/      # Server actions
│   └── prisma.ts     # Prisma client instance
├── store/            # Redux store configuration
├── types/            # TypeScript type definitions
└── test/             # Test files mirroring source structure
```

### File Naming
- Components: PascalCase (e.g., `ProductCard.tsx`)
- Utilities: camelCase (e.g., `formatCurrency.ts`)
- API routes: lowercase with hyphens (e.g., `route.ts`)
- Types: PascalCase interfaces/types (e.g., `Order.ts`)

---

## 4. Database & Prisma

### Prisma Client
- **Always use Prisma Client from `@/lib/prisma`** - Never create a new instance
- The client is properly configured with singleton pattern for development
- Use transactions for multi-step database operations

### Schema Changes
- Run migrations for schema changes: `npx prisma migrate dev --name description`
- **Never use `db push` in production** - Always use migrations
- Update seed files when adding new models or required fields
- Respect existing schema patterns (feature flags, roles, enums, etc.)

### Query Patterns
- Use `select` to limit fields returned (performance)
- Use `include` for relations when needed
- Handle database errors gracefully
- Use proper indexes for frequently queried fields

### Models to Know
- `User` - Customer and admin accounts with role-based access
- `Product` - Products with variants, images, inventory
- `Order` - Customer orders with order items
- `FeatureFlag` - Premium feature gating system
- `AdminActivityLog` - Audit trail of admin actions

---

## 5. Feature Flags

### Feature System
- Features are gated by PRO/ENTERPRISE tiers
- Feature flags stored in database (`FeatureFlag` model), not hardcoded
- Features are completely hidden when disabled (not just disabled)

### Implementation
- **Always check feature availability using `isFeatureEnabled()` from `@/lib/check-feature.ts`** before implementing premium features
- Check features on both client and server side when needed
- Use feature flags to conditionally render UI elements
- Document feature requirements in feature docs

### Feature Tiers
- **PRO**: Advanced features for professional users
- **ENTERPRISE**: Enterprise-level features
- Features can be enabled/disabled via `/admin/features` (SUPERADMIN only)

---

## 6. API Routes

### Route Handlers
- Use Next.js 13+ App Router API route format
- Place route handlers in `src/app/api/`
- Use proper HTTP methods (GET, POST, PUT, DELETE, PATCH)
- Return proper HTTP status codes

### Error Handling
- Always handle errors with try/catch
- Return consistent error response format: `{ error: string }`
- Use appropriate HTTP status codes (400, 401, 403, 404, 500)
- Log errors for debugging but don't expose sensitive details

### Authentication & Authorization
- Check authentication using NextAuth.js session
- Validate user permissions using role-based access control
- Use `getServerSession()` from `@/lib/auth.ts` for server-side auth
- Protect admin routes with proper role checks

### Request/Response
- Validate all inputs with Zod schemas
- Use TypeScript types for request/response bodies
- Return consistent JSON response structures
- Handle file uploads properly (use existing upload utilities)

---

## 7. Components

### Shadcn/ui Components
- Use components from `@/components/ui/`
- Don't modify base UI components directly - extend them if needed
- Follow Shadcn/ui patterns and conventions
- Use proper component composition

### Component Organization
- Admin components in `src/components/admin/`
- Storefront components in `src/components/storefront/`
- Shared UI components in `src/components/ui/`
- Block components in `src/components/blocks/`

### Best Practices
- Keep components small and focused
- Extract reusable logic into custom hooks
- Use proper TypeScript props interfaces
- Implement proper loading and error states
- Make components accessible (ARIA labels, keyboard navigation)

---

## 8. Testing

### Test Structure
- Write tests in `src/test/` mirroring source structure
- Test files should be named `*.test.ts` or `*.test.tsx`
- Use Vitest as the test runner
- Use React Testing Library for component tests

### Testing Patterns
- Mock Prisma client in tests (use test utilities)
- Test user interactions, not implementation details
- Use proper test data factories
- Clean up after tests (database, mocks, etc.)

### Coverage Goals
- Aim for 80%+ test coverage
- Focus on critical paths and business logic
- Test error cases and edge cases
- Test API routes with proper request/response mocking

### Running Tests
```bash
npm test              # Run all tests
npm test -- --watch   # Watch mode
npm test -- --coverage # With coverage report
```

---

## 9. Security

### Authentication
- Always use NextAuth.js for authentication
- Never store passwords in plain text (use bcrypt)
- Validate sessions on both client and server
- Implement proper session management

### Authorization
- **Always validate user permissions using role-based access control**
- Check user roles before allowing actions
- Use middleware for route protection when appropriate
- Respect role hierarchy: SUPERADMIN > ADMIN > MANAGER > EDITOR > SUPPORT > VIEWER

### Data Validation
- **Validate all inputs with Zod schemas**
- Sanitize user input to prevent XSS
- Use parameterized queries (Prisma handles this)
- Validate file uploads (type, size, content)

### Data Protection
- **Never expose sensitive data in client components**
- Don't log sensitive information
- Use environment variables for secrets
- Implement proper CORS policies
- Sanitize error messages (don't expose stack traces in production)

---

## 10. Performance

### React Server Components
- Use Server Components by default (better performance)
- Only use Client Components when necessary (interactivity, hooks, browser APIs)
- Minimize client-side JavaScript bundle size

### Data Fetching
- Use Server Components for data fetching when possible
- Use SWR for client-side data fetching with caching
- Implement proper loading states
- Use React Suspense for async components

### Optimization
- Optimize images with Next.js `Image` component
- Implement proper code splitting
- Use dynamic imports for heavy components
- Minimize re-renders with proper React patterns

### Database
- Use Prisma `select` to limit returned fields
- Implement proper database indexes
- Use pagination for large datasets
- Cache frequently accessed data when appropriate

---

## 11. Internationalization

### i18n Setup
- Use `next-intl` for all internationalization
- Translation files in `messages/[locale].json`
- Supported locales: `en`, `fr` (and more as needed)

### Implementation
- **Use `useTranslations()` hook in components** for all user-facing text
- Never hardcode user-facing strings
- Use translation keys with namespace: `t('namespace.key')`
- Provide translations for all new features

### Translation Keys
- Use descriptive, hierarchical keys (e.g., `admin.products.title`)
- Keep keys organized by feature/domain
- Update translation files for all locales when adding new text
- Use proper pluralization when needed

### Examples
```typescript
// In components
const t = useTranslations('admin.products');
return <h1>{t('title')}</h1>;

// In server components
import { getTranslations } from 'next-intl/server';
const t = await getTranslations('admin.products');
```

---

## 12. Additional Best Practices

### Code Quality
- Write self-documenting code with clear variable names
- Add comments for complex business logic
- Keep functions small and focused
- Follow DRY (Don't Repeat Yourself) principle
- Refactor when code duplication appears

### Git & Version Control
- Write clear, descriptive commit messages
- Keep commits focused on single changes
- Don't commit sensitive data or environment files
- Use meaningful branch names

### Documentation
- Update README.md when adding major features
- Document complex algorithms or business logic
- Keep API documentation up to date
- Document environment variables in `.env.example`

### Error Handling
- Always handle errors gracefully
- Provide user-friendly error messages
- Log errors for debugging
- Use proper error boundaries in React
- Implement retry logic for transient failures

### Accessibility
- Use semantic HTML elements
- Add proper ARIA labels
- Ensure keyboard navigation works
- Test with screen readers when possible
- Maintain proper color contrast

---

## 13. Common Patterns

### Server Actions
```typescript
'use server'
import { prisma } from '@/lib/prisma';
import { getServerSession } from '@/lib/auth';

export async function createProduct(data: ProductData) {
  const session = await getServerSession();
  if (!session || session.user.role !== 'ADMIN') {
    throw new Error('Unauthorized');
  }
  
  return await prisma.product.create({ data });
}
```

### Feature Checking
```typescript
import { isFeatureEnabled } from '@/lib/check-feature';

const isAnalyticsEnabled = await isFeatureEnabled('analytics');
if (!isAnalyticsEnabled) {
  return null; // Don't render feature
}
```

### Form Validation
```typescript
import { z } from 'zod';

const productSchema = z.object({
  name: z.string().min(3).max(100),
  price: z.number().positive(),
});

const result = productSchema.safeParse(formData);
if (!result.success) {
  return { error: result.error.errors[0].message };
}
```

### Translation Usage
```typescript
import { useTranslations } from 'next-intl';

function MyComponent() {
  const t = useTranslations('namespace');
  return <p>{t('key')}</p>;
}
```

---

## Notes

- These rules are living guidelines - they will be updated as the project evolves
- When in doubt, follow existing patterns in the codebase
- Consistency is more important than perfection
- Ask questions if something is unclear

---

*Last updated: [Auto-updated as rules are added]*

